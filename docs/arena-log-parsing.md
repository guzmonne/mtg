# Comprehensive Guide to Gathering Data from Magic: The Gathering Arena Logs

This document provides a detailed guide on how to locate, tail, and parse the
log files generated by Magic: The Gathering Arena to extract valuable gameplay
data. This information can be used to build sophisticated companion
applications, such as deck trackers, match history analyzers, and draft
helpers.

## 1. Locating the Log Files

The first step is to find where MTG Arena stores its log files. The location
varies depending on your operating system.

### macOS

On macOS, the log files are located in the following directory:

```bash
~/Library/Application Support/com.wizards.mtga/Logs/Logs/
```

### Windows

On Windows, the log files are located in a similar path within the user's `AppData` folder:

```
%USERPROFILE%\AppData\LocalLow\Wizards Of The Coast\MTGA\Logs\Logs
```

You can paste this path into the File Explorer address bar to access it directly.

### Identifying the Correct Log File

Inside the `Logs` directory, you will find multiple files, typically named with a timestamp, like `UTC_Log - 07-23-2025 19.35.31.log`. To get real-time data, you need to identify and monitor the most recently modified file.

You can do this from the command line:

- **macOS/Linux:**
  ```bash
  ls -lt "/Users/guzmanmonne/Library/Application Support/com.wizards.mtga/Logs/Logs" | head -n 2
  ```
- **Windows (PowerShell):**
  ```powershell
  Get-ChildItem -Path "$env:USERPROFILE\AppData\LocalLow\Wizards Of The Coast\MTGA\Logs\Logs" | Sort-Object -Descending -Property LastWriteTime | Select-Object -First 1
  ```

## 2. Tailing the Log File

MTG Arena writes to its log files in real-time. To capture this data as it's generated, you should "tail" the log file rather than reading it all at once. Tailing a file means monitoring it for new lines as they are added.

The `tail` command is the standard tool for this on macOS and Linux.

```bash
tail -f "/Users/guzmanmonne/Library/Application Support/com.wizards.mtga/Logs/Logs/UTC_Log - 07-23-2025 19.35.31.log"
```

For Windows, PowerShell provides a similar command:

```powershell
Get-Content -Path "C:\Users\YourUser\AppData\LocalLow\Wizards Of The Coast\MTGA\Logs\Logs\UTC_Log - 07-23-2025 19.35.31.log" -Wait
```

## 3. Understanding the Log Data Structure

The log files contain a mix of plain text and JSON objects. The most valuable data is encapsulated within these JSON objects. Each line in the log that contains a JSON object is a discrete, structured piece of information about an in-game event.

The most important JSON objects are:

- `MatchesV3`: Contains information about the match and the players.
- `greToClientEvent`: Provides detailed, real-time updates on the game state.
- `matchGameRoomStateChangedEvent`: Signals changes in the match's status, such as its completion.

## 4. Extracting and Parsing JSON with `jq`

To effectively work with the log data, you need to isolate the JSON objects from the rest of the log text and then parse them. The command-line tool `jq` is the ideal solution for this.

### Installation

- **macOS (using Homebrew):**
  ```bash
  brew install jq
  ```
- **Windows (using Chocolatey):**
  ```bash
  choco install jq
  ```

### Extraction Workflow

The process for extracting and parsing the data is as follows:

1.  **Tail the log file:** Use `tail -f` to get a continuous stream of log data.
2.  **Filter for relevant lines:** Use `grep` to select only the lines containing the JSON objects you're interested in.
3.  **Parse with `jq`:** Pipe the output to `jq` to extract and format the JSON.

Here is a command that combines these steps to extract `greToClientEvent` objects in real-time:

```bash
tail -f "path/to/your/log/file.log" | grep "greToClientEvent" | jq .greToClientEvent
```

## 5. Detailed Breakdown of Key JSON Payloads

### `MatchesV3`

This object appears at the start of a match and provides high-level information.

- `MatchId`: A unique identifier for the match.
- `PlayerInfos`: An array of objects, one for each player.
  - `ScreenName`: The player's screen name.
  - `RankingClass`: The player's rank (e.g., "Silver").
  - `RankingTier`: The player's tier within their rank.

### `greToClientEvent`

This is the most data-rich object, providing granular updates to the game state.

- `greToClientMessages`: An array of messages from the game engine.
  - `type`: The type of message (e.g., `GREMessageType_GameStateMessage`).
  - `gameStateMessage`: Contains the core game state information.
    - `gameInfo`: Match ID, game type, and other metadata.
    - `players`: An array of player objects with life totals, hand sizes, etc.
    - `turnInfo`: The current turn, phase, and active player.
    - `zones`: A detailed breakdown of all game zones (Hand, Library, Graveyard, Battlefield, etc.) with the `instanceId` of each card they contain.
    - `gameObjects`: An array of all objects in the game (cards, abilities, etc.), identified by `instanceId`. The `grpId` appears to be the unique identifier for a specific card.

### `matchGameRoomStateChangedEvent`

This object signals the end of a match.

- `finalMatchResult`: An object containing the outcome of the match.
  - `winningTeamId`: The ID of the winning team.

## 6. Practical Example: Tracking a Card Being Played

Let's walk through an example of how you would track a card being played from a player's hand to the battlefield.

1.  **Monitor the log:**

    ```bash
    tail -f "path/to/your/log/file.log" | grep "greToClientEvent" | jq .
    ```

2.  **Identify the "Play" action:** Look for a `gameStateMessage` where the `actions` array contains an action of type `ActionType_Play`.

3.  **Track the card's movement:**
    - In a `gameStateMessage` before the card is played, the card's `instanceId` will be in the `objectInstanceIds` array of the `Hand` zone for that player.
    - After the card is played, a new `gameStateMessage` will show the card's `instanceId` has moved to the `objectInstanceIds` array of the `Battlefield` zone.

By continuously parsing these messages, an application can maintain a complete and accurate representation of the current game state.

## 7. Automation and Scripting

To build a robust companion application, you will want to automate this process. You can write a script in a language like Python, Node.js, or Go that:

1.  Identifies the latest log file.
2.  Creates a child process to tail the file.
3.  Reads the output line by line.
4.  Filters for lines containing JSON.
5.  Parses the JSON to update the application's internal state.

This approach allows you to build a powerful, real-time tool that can provide invaluable insights to MTG Arena players.
