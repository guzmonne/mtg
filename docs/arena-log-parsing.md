# Comprehensive Guide to Gathering Data from Magic: The Gathering Arena Logs

This document provides a detailed guide on how to locate, tail, and parse the
log files generated by Magic: The Gathering Arena to extract valuable gameplay
data. This information can be used to build sophisticated companion
applications, such as deck trackers, match history analyzers, and draft
helpers.

## 1. Locating the Log Files

The first step is to find where MTG Arena stores its log files. The location
varies depending on your operating system.

### macOS

On macOS, the log files are located in the following directory:

```bash
~/Library/Application Support/com.wizards.mtga/Logs/Logs/
```

### Windows

On Windows, the log files are located in a similar path within the user's
`AppData` folder:

```
%USERPROFILE%\AppData\LocalLow\Wizards Of The Coast\MTGA\Logs\Logs
```

### Identifying the Correct Log File

Inside the `Logs` directory, you will find multiple files, typically named with
a timestamp, like `UTC_Log - 07-23-2025 19.35.31.log`. To get real-time data,
you need to identify and monitor the most recently modified file.

## 2. Tailing the Log File

MTG Arena writes to its log files in real-time. To capture this data as it's
generated, you should "tail" the log file rather than reading it all at once.
Tailing a file means monitoring it for new lines as they are added.

## 3. Understanding the Log Data Structure

The log files contain a mix of plain text and JSON objects. The most valuable
data is encapsulated within these JSON objects. Each line in the log that
contains a JSON object is a discrete, structured piece of information about an
in-game event.

The most important JSON objects are:

- `MatchesV3`: Contains information about the match and the players.
- `greToClientEvent`: Provides detailed, real-time updates on the game state.
- `matchGameRoomStateChangedEvent`: Signals changes in the match's status, such
  as its completion.

### Extraction Workflow

The process for extracting and parsing the data is as follows:

1.  **Tail the log file**
2.  **Filter for relevant lines**
3.  **Parse the JSON entries**

Here is a command that combines these steps to extract `greToClientEvent`
objects in real-time, if you were to do this in `bash`:

```bash
tail -f "path/to/your/log/file.log" | grep "greToClientEvent" | jq .greToClientEvent
```

## 5. Detailed Breakdown of Key JSON Payloads

### `MatchesV3`

This object appears at the start of a match and provides high-level information.

- `MatchId`: A unique identifier for the match.
- `PlayerInfos`: An array of objects, one for each player.
  - `ScreenName`: The player's screen name.
  - `RankingClass`: The player's rank (e.g., "Silver").
  - `RankingTier`: The player's tier within their rank.

### `greToClientEvent`

This is the most data-rich object, providing granular updates to the game state.

- `greToClientMessages`: An array of messages from the game engine.
  - `type`: The type of message (e.g., `GREMessageType_GameStateMessage`).
  - `gameStateMessage`: Contains the core game state information.
    - `gameInfo`: Match ID, game type, and other metadata.
    - `players`: An array of player objects with life totals, hand sizes, etc.
    - `turnInfo`: The current turn, phase, and active player.
    - `zones`: A detailed breakdown of all game zones (Hand, Library, Graveyard, Battlefield, etc.) with the `instanceId` of each card they contain.
    - `gameObjects`: An array of all objects in the game (cards, abilities, etc.), identified by `instanceId`. The `grpId` appears to be the unique identifier for a specific card.

### `matchGameRoomStateChangedEvent`

This object signals the end of a match.

- `finalMatchResult`: An object containing the outcome of the match.
  - `winningTeamId`: The ID of the winning team.

## 6. Practical Example: Tracking a Card Being Played

Let's walk through an example of how you would track a card being played from
a player's hand to the battlefield.

> We'll assume we are using `bash`.

1.  **Monitor the log:**

    ```bash
    tail -f "$LOG_FILE" | grep "greToClientEvent" | jq .
    ```

2.  **Identify the "Play" action:** Look for a `gameStateMessage` where the
    `actions` array contains an action of type `ActionType_Play`.

3.  **Track the card's movement:**
    - In a `gameStateMessage` before the card is played, the card's
      `instanceId` will be in the `objectInstanceIds` array of the `Hand` zone
      for that player.
    - After the card is played, a new `gameStateMessage` will show the card's
      `instanceId` has moved to the `objectInstanceIds` array of the
      `Battlefield` zone.

By continuously parsing these messages, an application can maintain a complete
and accurate representation of the current game state.

## 7. Automation and Scripting

To build a robust companion application, you will want to automate this
process. You can write a script in a language like Python, Node.js, Go, or Rust
that:

1.  Identifies the latest log file.
2.  Creates a child process to tail the file.
3.  Reads the output line by line.
4.  Filters for lines containing JSON.
5.  Parses the JSON to update the application's internal state.

This approach allows you to build a powerful, real-time tool that can provide
invaluable insights to MTG Arena players.
